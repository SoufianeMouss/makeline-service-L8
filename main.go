package main

import (
	"log"
	"net/http"
	"os"
	"strconv"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
)

// Valid database API types
const (
	AZURE_COSMOS_DB_SQL_API = "cosmosdbsql"
)

func main() {
	var orderService *OrderService

	// Get the database API type
	apiType := os.Getenv("ORDER_DB_API")
	switch apiType {
	case "cosmosdbsql":
		log.Printf("Using Azure CosmosDB SQL API")
	default:
		log.Printf("Using MongoDB API")
	}

	// Initialize the database
	orderService, err := initDatabase(apiType)
	if err != nil {
		log.Printf("Failed to initialize database: %s", err)
		os.Exit(1)
	}

	router := gin.Default()
	router.Use(cors.Default())
	router.Use(OrderMiddleware(orderService))

	// For makeline/worker: fetch from queue, insert into DB, then return pending orders
	router.GET("/order/fetch", fetchOrders)

	// For admin UI: list orders directly from DB (optionally filtered by status)
	// Example: GET /order?status=1   (status=Processing)
	//          GET /order?status=2   (status=Complete / shipped)
	//router.GET("/order", listOrders)
	router.GET("/order", listOrdersByStatus)

	// Get single order
	router.GET("/order/:id", getOrder)

	// Update order (status, items, etc.)
	router.PUT("/order", updateOrder)

	// Health check
	router.GET("/health", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{
			"status":  "ok",
			"version": os.Getenv("APP_VERSION"),
		})
	})

	router.Run(":3001")
}

// GET /order?status=0|1|2
func listOrdersByStatus(c *gin.Context) {
    client, ok := c.MustGet("orderService").(*OrderService)
    if !ok {
        log.Printf("Failed to get order service")
        c.AbortWithStatus(http.StatusInternalServerError)
        return
    }

    statusParam := c.Query("status")
    if statusParam == "" {
        c.AbortWithStatus(http.StatusBadRequest)
        return
    }

    s, err := strconv.Atoi(statusParam)
    if err != nil || s < 0 || s > 2 {
        c.AbortWithStatus(http.StatusBadRequest)
        return
    }

    orders, err := client.repo.GetOrdersByStatus(Status(s))
    if err != nil {
        log.Printf("Failed to get orders by status: %s", err)
        c.AbortWithStatus(http.StatusInternalServerError)
        return
    }

    c.IndentedJSON(http.StatusOK, orders)
}


// OrderMiddleware is a middleware function that injects the order service into the request context
func OrderMiddleware(orderService *OrderService) gin.HandlerFunc {
	return func(c *gin.Context) {
		c.Set("orderService", orderService)
		c.Next()
	}
}

// Fetches orders from the order queue, stores them in database, then returns pending orders
// This is primarily for the makeline/worker flow.
func fetchOrders(c *gin.Context) {
	client, ok := c.MustGet("orderService").(*OrderService)
	if !ok {
		log.Printf("Failed to get order service")
		c.AbortWithStatus(http.StatusInternalServerError)
		return
	}

	// Get orders from the queue
	orders, err := getOrdersFromQueue()
	if err != nil {
		log.Printf("Failed to fetch orders from queue: %s", err)
		c.AbortWithStatus(http.StatusInternalServerError)
		return
	}

	// Save orders to database
	err = client.repo.InsertOrders(orders)
	if err != nil {
		log.Printf("Failed to save orders to database: %s", err)
		c.AbortWithStatus(http.StatusInternalServerError)
		return
	}

	// Return the orders to be processed (pending)
	orders, err = client.repo.GetPendingOrders()
	if err != nil {
		log.Printf("Failed to get pending orders from database: %s", err)
		c.AbortWithStatus(http.StatusInternalServerError)
		return
	}

	c.IndentedJSON(http.StatusOK, orders)
}

// listOrders reads orders directly from the database.
// If the "status" query parameter is provided, it filters by that numeric Status.
// Example: GET /order?status=1  (Processing)
//          GET /order?status=2  (Complete / shipped)
func listOrders(c *gin.Context) {
	client, ok := c.MustGet("orderService").(*OrderService)
	if !ok {
		log.Printf("Failed to get order service")
		c.AbortWithStatus(http.StatusInternalServerError)
		return
	}

	statusParam := c.Query("status")

	var (
		orders []Order
		err    error
	)

	if statusParam != "" {
		// parse status as int and cast to Status enum
		statusInt, parseErr := strconv.Atoi(statusParam)
		if parseErr != nil {
			log.Printf("Invalid status query value: %s", statusParam)
			c.AbortWithStatus(http.StatusBadRequest)
			return
		}

		status := Status(statusInt)

		// You will implement GetOrdersByStatus(status Status) on the repo
		orders, err = client.repo.GetOrdersByStatus(status)
	} else {
		// Fallback: reuse existing pending-orders method
		orders, err = client.repo.GetPendingOrders()
	}

	if err != nil {
		log.Printf("Failed to get orders from database: %s", err)
		c.AbortWithStatus(http.StatusInternalServerError)
		return
	}

	c.IndentedJSON(http.StatusOK, orders)
}

// Gets a single order from database by order ID
func getOrder(c *gin.Context) {
	client, ok := c.MustGet("orderService").(*OrderService)
	if !ok {
		log.Printf("Failed to get order service")
		c.AbortWithStatus(http.StatusInternalServerError)
		return
	}

	id, err := strconv.Atoi(c.Param("id"))
	if err != nil {
		log.Printf("Failed to convert order id to int: %s", err)
		c.AbortWithStatus(http.StatusBadRequest)
		return
	}

	sanitizedOrderId := strconv.FormatInt(int64(id), 10)

	order, err := client.repo.GetOrder(sanitizedOrderId)
	if err != nil {
		log.Printf("Failed to get order from database: %s", err)
		c.AbortWithStatus(http.StatusInternalServerError)
		return
	}

	c.IndentedJSON(http.StatusOK, order)
}

// Updates the status of an order
// For the admin "Ship" action, the UI will send PUT /order with a numeric status,
// e.g. status = 2 (Complete = shipped).
func updateOrder(c *gin.Context) {
	client, ok := c.MustGet("orderService").(*OrderService)
	if !ok {
		log.Printf("Failed to get order service")
		c.AbortWithStatus(http.StatusInternalServerError)
		return
	}

	// unmarshal the order from the request body
	var order Order
	if err := c.BindJSON(&order); err != nil {
		log.Printf("Failed to unmarshal order: %s", err)
		c.AbortWithStatus(http.StatusInternalServerError)
		return
	}

	id, err := strconv.Atoi(order.OrderID)
	if err != nil {
		log.Printf("Failed to convert order id to int: %s", err)
		c.AbortWithStatus(http.StatusBadRequest)
		return
	}

	sanitizedOrderId := strconv.FormatInt(int64(id), 10)

	sanitizedOrder := Order{
		OrderID:    sanitizedOrderId,
		CustomerID: order.CustomerID,
		Items:      order.Items,
		Status:     order.Status, // e.g. Pending(0), Processing(1), Complete(2)
	}

	err = client.repo.UpdateOrder(sanitizedOrder)
	if err != nil {
		log.Printf("Failed to update order status: %s", err)
		c.AbortWithStatus(http.StatusInternalServerError)
		return
	}

	// 202 Accepted â€“ update is processed
	c.Status(http.StatusAccepted)
}

// Gets an environment variable or exits if it is not set
func getEnvVar(varName string, fallbackVarNames ...string) string {
	value := os.Getenv(varName)
	if value == "" {
		for _, fallbackVarName := range fallbackVarNames {
			value = os.Getenv(fallbackVarName)
			if value == "" {
				break
			}
		}
		if value == "" {
			log.Printf("%s is not set", varName)
			if len(fallbackVarNames) > 0 {
				log.Printf("Tried fallback variables: %v", fallbackVarNames)
			}
			os.Exit(1)
		}
	}
	return value
}

// Initializes the database based on the API type
func initDatabase(apiType string) (*OrderService, error) {
	dbURI := getEnvVar("AZURE_COSMOS_RESOURCEENDPOINT", "ORDER_DB_URI")
	dbName := getEnvVar("ORDER_DB_NAME")

	switch apiType {
	case AZURE_COSMOS_DB_SQL_API:
		containerName := getEnvVar("ORDER_DB_CONTAINER_NAME")
		dbPartitionKey := getEnvVar("ORDER_DB_PARTITION_KEY")
		dbPartitionValue := getEnvVar("ORDER_DB_PARTITION_VALUE")

		// check if USE_WORKLOAD_IDENTITY_AUTH is set
		useWorkloadIdentityAuth := os.Getenv("USE_WORKLOAD_IDENTITY_AUTH")
		if useWorkloadIdentityAuth == "" {
			useWorkloadIdentityAuth = "false"
		}

		if useWorkloadIdentityAuth == "true" {
			cosmosRepo, err := NewCosmosDBOrderRepoWithManagedIdentity(dbURI, dbName, containerName, PartitionKey{dbPartitionKey, dbPartitionValue})
			if err != nil {
				return nil, err
			}
			return NewOrderService(cosmosRepo), nil
		} else {
			dbPassword := os.Getenv("ORDER_DB_PASSWORD")
			cosmosRepo, err := NewCosmosDBOrderRepo(dbURI, dbName, containerName, dbPassword, PartitionKey{dbPartitionKey, dbPartitionValue})
			if err != nil {
				return nil, err
			}
			return NewOrderService(cosmosRepo), nil
		}
	default:
		collectionName := getEnvVar("ORDER_DB_COLLECTION_NAME")
		dbUsername := os.Getenv("ORDER_DB_USERNAME")
		dbPassword := os.Getenv("ORDER_DB_PASSWORD")
		mongoRepo, err := NewMongoDBOrderRepo(dbURI, dbName, collectionName, dbUsername, dbPassword)
		if err != nil {
			return nil, err
		}
		return NewOrderService(mongoRepo), nil
	}
}
